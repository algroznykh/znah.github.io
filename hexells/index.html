<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<script src="twgl-full.min.js"></script>
<script src="dat.gui.min.js"></script>
<script src="ca.js" type="module"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-15552566-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'UA-15552566-1');
</script>


<style>
html, body {
  margin: 0px;
}
canvas {
  width: 100vw;
  height: 100vh;
}

#fsButton {
  position: fixed;
  z-index: 10;
  bottom: 20px; left:20px;
}

#info{
  position: absolute;
  top: 50%;
  left: 50%;
  width: 300px;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.75);
  padding: 20px;
  color: #FFF;
  z-index:5;
  font-family: 'Google Sans', Arial, Helvetica, sans-serif;
}

a:link {
  color: red;
}

a:visited {
  color: red;
}
</style>


<div id='info'>
  <p> <b style="font-size: larger;">Hexells</b> <br>
  by <a href="https://twitter.com/zzznah">Alexander Mordvintsev</a>

  <p>
    The is an Artifitial Self-Organising System. Cells were trained to build textures
     by communicating with neighbours only. The system is based on the 
     <a href="https://distill.pub/2020/growing-ca/">Neural Cellular Automata</a> architecture.
  </p>

  <p>
    Touch to interact; swipe left or right to change the pattern.
  </p>

  <div id="hideBtn" style="text-align: center;"><button>Hide</button></div>

  

</div>

<canvas id="glCanvas"></canvas>
<button id="fsButton">Fullscreen</button>


<!-- <img id="icons" src="icons.jpeg"></img><br>
<pre id="log"></pre> -->

<script type="module">
  import { CA } from "./ca.js"

  const canvas = document.querySelector('#glCanvas');

  document.getElementById('fsButton').onclick = ()=>{
    const elem = canvas;
    const opt = { navigationUI: "hide" };
    if (elem.requestFullscreen) {
      elem.requestFullscreen(opt);
    } else if (elem.webkitRequestFullscreen) { /* Safari */
      elem.webkitRequestFullscreen(opt);
    } else if (elem.msRequestFullscreen) { /* IE11 */
      elem.msRequestFullscreen(opt);
    }
  };
  
  document.getElementById('hideBtn').onclick = ()=>{
    document.getElementById('info').style.display = 'none';
  };

  const gl = canvas.getContext("webgl");
  const gui = new dat.GUI();
  gui.hide();
  const param = {
    active: true,
    model: 149,
    brushRadius: 16,
    zoom: 1,
    stepPerFrame: 1,
    paintMode: false,
  };
  gui.add(param, 'active');
  gui.add(param, 'brushRadius', 1, 40);
  gui.add(param, 'zoom', 1.0, 64.0);
  gui.add(param, 'stepPerFrame', 0, 6);
  gui.add(param, 'paintMode', 0, 6);

  fetch('models.json').then(r => r.json()).then(models => {
    const onready = ()=>{
      if (window.location.search == '?frame') {
        param.active = false;
        for (let i=0; i<200; ++i) ca.step();
        document.getElementById('fsButton').style.display = "none";
        document.getElementById('info').style.display = 'none';
      }
    };
    const ca = new CA(gl, models, [160, 160], gui, onready);
    window.ca = ca;
    ca.alignment = 0;
    
    const name2idx = Object.fromEntries(models.model_names.map((s, i) => [s, i]));
    gui.add(param, 'model').options(name2idx).listen();
    // document.getElementById('icons').addEventListener('click', e=>{
    //   const tileSize = 48;
    //   const tx = Math.floor(e.offsetX/tileSize);
    //   const ty = Math.floor(e.offsetY/tileSize);
    //   const i = ty*20+tx;
    //   console.log(i);
    //   param.model = i<models.model_names.length ? i : -1;
    //   if (!param.paintMode) {
    //     ca.paint(0, 0, -1, i);
    //     ca.clearCircle(0, 0, -1);
    //   }
    // });
    // ca.paint(0, 0, -1, param.model);

    function getMousePos(e) {
      return [e.offsetX, e.offsetY];
    }
    function getTouchPos(touch) {
      const rect = canvas.getBoundingClientRect();
      return [touch.clientX - rect.left, touch.clientY - rect.top];
    }

    function touch(pos) {
      let [x, y] = pos;
      const viewSize = [canvas.clientWidth, canvas.clientHeight];
      if ( param.paintMode ) {
        ca.paint(x, y, param.brushRadius, param.model, viewSize);
      } else {
        ca.clearCircle(x, y, param.brushRadius, viewSize);
      }
    };

    const shuffledModels = models.model_names.map((_, i)=>[Math.random(), i]).sort().map(p=>p[1]);
    ca.paint(0, 0, -1, 132);
    let curModel = shuffledModels.indexOf(132);
    let geusture = null;
    function startGuestue(pos) {
      geusture = {pos, time: Date.now()};
    }
    function endGuestue(pos) {
      if (!geusture)
       return;
      if (Date.now()-geusture.time < 1000) {
        const [x0, y0] = geusture.pos;
        const [x, y] = pos;
        const dx = x-x0;
        if (Math.abs(dx) > 100 && Math.abs(y-y0)<Math.abs(dx)*0.25)  {
            const n = shuffledModels.length;
            curModel = (curModel+n+Math.sign(dx)) % n;
            console.log(shuffledModels[curModel]);
            ca.paint(0, 0, -1, shuffledModels[curModel]);
            ca.disturb();
        }
      }
      geusture = null;
    }

    canvas.onmousedown = e => {
      e.preventDefault();
      if (e.buttons == 1) {
        const pos = getMousePos(e);
        touch(pos);
        startGuestue(pos);
      }
    }
    canvas.onmousemove = e => {
      e.preventDefault();
      if (e.buttons == 1) {
        touch(getMousePos(e));
      }
    }
    canvas.onmouseup = e => {
      e.preventDefault();
      endGuestue(getMousePos(e));
    }

    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      const pos = getTouchPos(e.changedTouches[0]);
      touch(pos);
      if (e.touches.length == 1) {
        startGuestue(pos);
      } else {
        geusture = null;
      }
    });
    canvas.addEventListener("touchmove", e => {
      e.preventDefault();
      for (const t of e.touches) {
        touch(getTouchPos(t));
      }
    });
    canvas.addEventListener("touchend", e => {
      e.preventDefault();
      endGuestue(getTouchPos(e.changedTouches[0]));
    });
    param.benchmark = ()=>{
      document.getElementById('log').insertAdjacentHTML('afterbegin', ca.benchmark());
    }
    gui.add(param, 'benchmark');

    function render() {
      if (param.active) {
        ca.step();
      }
      
      const devicePixelRatio = window.devicePixelRatio || 1;
      canvas.width = Math.round(canvas.clientWidth * devicePixelRatio);
      canvas.height = Math.round(canvas.clientHeight * devicePixelRatio);      
      const viewSize = [canvas.clientWidth, canvas.clientHeight];

      twgl.bindFramebufferInfo(gl);
      ca.draw(viewSize);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  })
</script>
